# ConstructorSuperOCA5

public class Mammal {
  public Mammal(int age) {
  }}
public class Elephant extends Mammal { 
 public Elephant() {  
  super(10);  
}}
Этот код скомпилируется, потому что мы добавили конструктор с явным вызовом родительского конструктора. Обратите внимание, что класс Elephantтеперь имеет конструктор без аргументов, хотя его родительский класс Mammalне имеет. Подклассы могут определять конструкторы без аргументов, даже если их родительские классы этого не делают, при условии, что конструктор дочернего объекта отображается на родительский конструктор посредством явного вызова super()команды.
Вам следует остерегаться любого экзаменационного вопроса, в котором родительский класс определяет конструктор, который принимает аргументы и не определяет
конструктор без аргументов. Не забудьте проверить, что код компилируется, прежде чем ответить на вопрос об этом.


Просмотр правил конструктора


Давайте рассмотрим правила, которые мы рассмотрели в этом разделе.

Правила определения конструктора:

1.	Первым оператором каждого конструктора является вызов другого конструктора внутри класса используя this()или вызов конструктора в прямом родительском классе используя super().
2.	super()Вызов не может быть использован после первого заявления конструктора.
3.	Если нет super() вызов объявлен в конструкторе, Java вставит без аргумента super()в качестве первого оператора конструктора.
4.	Если у родителя нет конструктора без аргументов, а потомок не определяет конструкторов, компилятор выдаст ошибку и попытается вставить конструктор по умолчанию без аргументов в дочерний класс.
5.	Если у родителя нет конструктора без аргументов, компилятор требует явного вызова родительского конструктора в каждом дочернем конструкторе.
Убедитесь, что вы понимаете эти правила; экзамен часто дает код, который нарушает одно или многие из этих правил и поэтому не компилируется.
Вызов конструкторов
Теперь, когда мы рассмотрели, как определить допустимый конструктор, мы покем вам, как Java вызывает конструкторы. В Java родительский конструктор всегда выполняется перед дочерним конструктором. Например, попытайтесь определить, что выводит следующий код:

class Primate {
  public Primate() {  
  System.out.println("Primate"); 
 }}
class Ape extends Primate {
  public Ape() {  
  System.out.println("Ape");  
}}
public class Chimpanzee extends Ape { 
 public static void main(String[] args) {   
 new Chimpanzee(); 
 }}
Сначала компилятор вставляет super()команду как первый оператор как конструкторов, так Primateи Ape. Затем компилятор вставляет конструктор по умолчанию без аргументов в Chimpanzeeкласс с super()первым оператором конструктора. Код будет выполняться с родительскими конструкторами, вызванными first, и даст следующий вывод:

Primate
Ape
